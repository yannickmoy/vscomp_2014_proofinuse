


(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)


module Patience

  use import int.Int
  use import list.List
  use import list.Append
  use import list.Reverse

  (** {2 Specifications} *)

  (** a sequence of stacks of well-formed iff each stack is non-empty
      and increasing *)

  predicate increasing_stack (stack: list int) =
    match stack with
    | Nil -> false
    | Cons _ Nil -> true
    | Cons c1 (Cons c2 _ as rem) -> c1 <= c2 /\ increasing_stack rem
    end

  predicate wf_stacks (stacks: list (list int)) =
    match stacks with
    | Nil -> true
    | Cons s rem -> increasing_stack s /\ wf_stacks rem
    end

  (** lemma: concatenation of well-formed sequences of stacks results in
      a well-formed sequence of stacks.
      Structural induction done vie a lemma function
  *)
  let rec lemma wf_append_stacks (s1 s2: list (list int))
    requires { wf_stacks s1 }
    requires { wf_stacks s2 }
    variant { s1 }
    ensures { wf_stacks (s1 ++ s2) }
  = match s1 with
    | Nil -> ()
    | Cons _ rem -> wf_append_stacks rem s2
    end

  (** {2 Programs} *)

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks], assuming
      [acc] is an accumulator (in reverse order) of stacks where [c] could not be pushed *)
  let rec push_card c stacks acc
    requires { wf_stacks stacks }
    requires { wf_stacks (reverse acc) }
    variant  { stacks }
    ensures  { wf_stacks result }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      reverse (Cons (Cons c Nil) acc)
    | Cons stack stacks ->
        match stack with
        | Nil -> absurd
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             (reverse (Cons (Cons c stack) acc)) ++ stacks
           else
             (* try next stack *)
             push_card c stacks (Cons stack acc)
        end
     end

  let rec play_cards (input: list int) (stacks: list (list int))
    : list (list int)
    requires { wf_stacks stacks }
    variant  { input }
    ensures  { true }
  =
    match input with
    | Nil -> stacks
    | Cons c rem -> play_cards rem (push_card c stacks Nil)
    end


  let play_game (input: list int) : list (list int)
    requires { true }
    ensures { true }
  = play_cards input Nil


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end