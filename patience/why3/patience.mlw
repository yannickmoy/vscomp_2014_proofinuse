

(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)



(** {2 Preliminary: pigeon-hole lemma} *)


module PigeonHole

(** The Why standard library provides a lemma
    [map.MapInjection.injective_surjective] stating that a map from
    [(0..n-1)] to to [(0..n-1)] that is an injection is also a
    surjection.

    This is more or less equivalent to the pigeon-hole lemma. However, we need such a lemma more generally on functions instead of maps.

    Thus we restate the pigeon-hole lemma here. Proof is left as an exercise.

*)

  use import int.Int
  use HighOrd

  predicate range (f: int -> int) (n: int) (m:int) =
    forall i: int. 0 <= i < n -> 0 <= f(i) < m
  (** [range f n m] is true when [f] maps the domain
      [(0..n-1)] into [(0..m-1)] *)

  predicate injective (f: int -> int) (n: int) (m:int) =
    forall i j: int. 0 <= i < j < n -> f i <> f j
  (** [injective f n m] is true when [f] is an injection
      from [(0..n-1)] to [(0..m-1)] *)

  lemma pigeon_hole :
    forall n,m:int, f: int -> int.
    range f n m /\ n > m -> not injective f n m

end




(** {2 Patience unproved code} *)


module PatienceCode

  use import int.Int
  use import list.List
  use import list.RevAppend

  (** this code was the one written initially, without any
      specification or proofs, except for termination.
      It can be tested, see below. *)

  type card = int

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.
  *)
  let rec push_card (c:card) (stacks : list (list card))
     (acc : list (list card)) : list (list card)
    variant  { stacks }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      rev_append (Cons (Cons c Nil) acc) Nil
    | Cons stack remaining_stacks ->
        match stack with
        | Nil -> absurd (* can not be proved unreachable yet *)
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             rev_append (Cons (Cons c stack) acc) remaining_stacks
           else
             (* try next stack *)
             push_card c remaining_stacks (Cons stack acc)
        end
     end

  let rec play_cards (input: list card) (stacks: list (list card))
    : list (list card) 
    variant { input }
  =
    match input with
    | Nil -> stacks
    | Cons c rem ->
        let stacks' = push_card c stacks Nil in
        play_cards rem stacks'
    end


  let play_game (input: list card) : list (list card) =
    play_cards input Nil


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end


(** {2 Patience game with specifications and proofs} *)

module Patience

  use import int.Int

  type card = int

  (** {3 Ghost state} *)

  (** To specify the expected behavior of the code, we attach a ghost
      state to each step of the algorithm. This state provides extra
      information needed for the final properties to establish.

  *)

  use import map.Map

  type state = {
    mutable num_elts : int;
    (** number of cards already seen *)
    mutable values : map int card;
    (** cards values seen, indexed in the order they have been seen, 
        from [0] to [num_elts-1] *)
    mutable num_stacks : int;
    (** number of stacks built so far *)
    mutable stack_sizes : map int int;
    (** sizes of these stacks, numbered from [0] to [num_stacks - 1] *)
    mutable stacks : map int (map int int);
    (** indexes of the cards in respective stacks *)
    mutable positions : map int (int,int);
    (** table that given a card index, provides its position, i.e. in
        which stack it is and at which height *)
    mutable preds : map int int;
    (** predecessors of cards, i.e. for each card index [i], [preds[i]]
        provides an index of a card in the stack on the immediate left, 
        whose value is smaller. returns [-1] of the card is on the 
        leftmost stack. *)
  }

(** Invariants on the ghost state *)

  predicate inv (s:state) =
     0 <= s.num_stacks <= s.num_elts
     (** the number of stacks is less or equal the number of cards *)
  /\ (s.num_elts > 0 -> s.num_stacks > 0)
     (** when there is at least one card, there is at least one stack *)
  /\ (forall i. 0 <= i < s.num_stacks ->
         s.stack_sizes[i] >= 1 
         (** stacks are non-empty *)
      /\ forall j. 0 <= j < s.stack_sizes[i] ->
           0 <= s.stacks[i][j] < s.num_elts)
         (** contents of stacks are valid card indexes *)
  /\ (forall i. 0 <= i < s.num_elts ->
       let (is,ip) = s.positions[i] in
       0 <= is < s.num_stacks &&
       let st = s.stacks[is] in
         0 <= ip < s.stack_sizes[is] &&
         st[ip] = i)
     (** the position table of cards is correct, i.e. when 
        [(is,ip) = s.positions[i]] then card [i] is indeed
        stored in stack [is] at height [ip] *)
  /\ (forall is. 0 <= is < s.num_stacks ->
        forall ip. 0 <= ip < s.stack_sizes[is] ->
        let idx = s.stacks[is][ip] in
        (is,ip) = s.positions[idx])
     (** positions is the right inverse of stacks *)
  /\ (forall i. 0 <= i < s.num_stacks ->
        let stack_i = s.stacks[i] in
        forall j,k. 0 <= j < k < s.stack_sizes[i] ->
           stack_i[j] < stack_i[k])
     (** in a given stack, indexes are increasing *)
  /\ (forall i. 0 <= i < s.num_stacks ->
        let stack_i = s.stacks[i] in
        forall j,k. 0 <= j <= k < s.stack_sizes[i] ->
           s.values[stack_i[j]] >= s.values[stack_i[k]])
     (** in a given stack, card values are decreasing *)
  /\ (forall i. 0 <= i < s.num_elts ->
       let pred = s.preds[i] in
       -1 <= pred < s.num_elts &&
       (** the predecessor is a valid index or [-1] *)
       pred < i /\ 
       (** predecessor is always a smaller index *)
       let (is,_ip) = s.positions[i] in
       if pred < 0 then is = 0 
         (** if predecessor is [-1] then [i] is in leftmost stack *)
       else
         s.values[pred] < s.values[i] /\ 
         (** if predecessor is not [-1], it denotes a card with smaller value... *)
         is > 0 &&
         (** ...the card is not on the leftmost stack... *)
         let (ps,_pp) = s.positions[pred] in
         ps = is - 1) 
         (** and predecessor is in the stack on the immediate left *)


(*

  use import list.List
  use import list.Length
  use import list.Append
  use import list.RevAppend
  use import list.Reverse

  use import list.NthNoOpt (* for the [nth] operator on lists *)

  (** these lemmas should have been in Why3 stdlib ! *)
  let rec lemma nth_append_1 (l1 l2: list 'a) (i: int)
    requires { 0 <= i < length l1 }
    variant  { l1 }
    ensures  { nth i (l1 ++ l2) = nth i l1 }
  = match l1 with
    | Nil -> ()
    | Cons _ l -> if i = 0 then () else nth_append_1 l l2 (i-1)
    end

  let rec lemma nth_append_2 (l1 l2: list 'a) (i: int)
    requires { length l1 <= i < length l1 + length l2 }
    variant  { l1 }
    ensures  { nth i (l1 ++ l2) = nth (i - length l1) l2 }
  = match l1 with
    | Nil -> ()
    | Cons _ l -> nth_append_2 l l2 (i-1)
    end

  predicate inv (s:state) (stacks:list (list int)) =
    s.num_elts >= 0
  /\
    (** [s.top_stacks[i]] denotes the index
        of the top of the [i]-th stack of [stacks] *)
    (forall i. 0 <= i < length stacks ->
      let stack_i = nth i stacks in
      match stack_i with
      | Nil -> false (* stacks are non-empty *)
      | Cons hd _ ->
        let idx = s.top_stacks[i] in
        0 <= idx < s.num_elts /\ let (e,_) = s.elts[idx] in e = hd
      end)
  /\
    (forall i. 0 <= i < s.num_elts ->
      let j = s.preds[i] in
        -1 <= j < s.num_elts /\ (j >= 0 ->
          let (ej,sj) = s.elts[j] in
          let (ei,si) = s.elts[i] in
          ej < ei /\ si > 0 /\ sj = si - 1))

  (** {2 Programs} *)

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.
  *)

  let rec push_card (c:int) (stacks : list (list int))
     (acc : list (list int)) (ghost s: state)
     : list (list int)
    requires { inv s (reverse acc ++ stacks) }
    requires { (* c is greater than the top of the previous stack *)
               match acc with
               | Cons (Cons c' _) _ -> c > c'
               | _ -> true
               end }
    variant  { stacks }
    writes   { s }
    ensures  { inv s result }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      let new_stacks = reverse (Cons (Cons c Nil) acc) in
      (* update of the ghost state *)
      let ghost old_stacks = reverse acc ++ stacks in
      let ghost lacc = length acc in
      assert { lacc = length old_stacks };
      assert { old_stacks = reverse acc };
      assert { new_stacks = old_stacks ++ (Cons (Cons c Nil) Nil) };
      assert { length new_stacks = length old_stacks + 1 };
      assert { forall i. 0 <= i < lacc ->
                 nth i new_stacks = nth i old_stacks };
      assert { nth lacc new_stacks = Cons c Nil };
      let ghost l = s.num_elts in
      s.num_elts <- l + 1;
      s.elts <- s.elts[l <- (c,lacc)];
      let ghost p = if lacc = 0 then -1 else s.top_stacks[lacc-1] in
      s.preds <- s.preds[l <- p];
      s.top_stacks <- s.top_stacks[lacc <- l];
      new_stacks
    | Cons stack remaining_stacks ->
        match stack with
        | Nil ->
            let ghost lacc = length acc in
            assert { stack = nth lacc (reverse acc ++ stacks) };
            absurd
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             let new_stacks =
               (* TODO: use rev_append directly for efficiency of the code *)
               (reverse (Cons (Cons c stack) acc)) ++ remaining_stacks in
             (* update of the ghost state *)
             let ghost old_stacks = reverse acc ++ stacks in
             assert { new_stacks =
               reverse acc ++ (Cons (Cons c stack) Nil) ++ remaining_stacks };
             assert { length new_stacks = length old_stacks };
             let ghost lacc = length acc in
             assert { forall i. 0 <= i < length old_stacks ->
               i <> lacc -> nth i new_stacks = nth i old_stacks };
             assert { nth lacc new_stacks = Cons c (nth lacc old_stacks) } ;
             let ghost l = s.num_elts in
             s.num_elts <- l + 1;
             s.elts <- s.elts[l<-(c,lacc)];
             let ghost p = if lacc = 0 then -1 else s.top_stacks[lacc-1] in
             s.preds <- s.preds[l <- p];
             s.top_stacks <- s.top_stacks[lacc <- l];
             new_stacks
           else
             (* try next stack *)
             push_card c remaining_stacks (Cons stack acc) s
        end
     end

  let rec play_cards (input: list int) (stacks: list (list int))
    (ghost s: state) : list (list int)
    requires { inv s stacks }
    variant  { input }
    writes   { s }
    requires { inv s stacks }
  =
    match input with
    | Nil -> stacks
    | Cons c rem ->
        let stacks' = push_card c stacks Nil s in
        play_cards rem stacks' s
    end


  let play_game (input: list int) : list (list int)
    requires { true }
    ensures { true }
  = let ghost s = {
      num_elts = 0;
      elts = Map.const (-1,-1) ;
      top_stacks = Map.const (-1);
      preds = Map.const (-1);
    }
    in
    play_cards input Nil s


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))
*)

end