

(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)



(** {2 Preliminary: pigeon-hole lemma} *)


module PigeonHole

(** The Why standard library provides a lemma
    [map.MapInjection.injective_surjective] stating that a map from
    [(0..n-1)] to to [(0..n-1)] that is an injection is also a
    surjection.

    This is more or less equivalent to the pigeon-hole lemma. However, we need such a lemma more generally on functions instead of maps.

    Thus we restate the pigeon-hole lemma here. Proof is left as an exercise.

*)

  use import int.Int
  use HighOrd

  predicate range (f: int -> int) (n: int) (m:int) =
    forall i: int. 0 <= i < n -> 0 <= f(i) < m
  (** [range f n m] is true when [f] maps the domain
      [(0..n-1)] into [(0..m-1)] *)

  predicate injective (f: int -> int) (n: int) (m:int) =
    forall i j: int. 0 <= i < j < n -> f i <> f j
  (** [injective f n m] is true when [f] is an injection
      from [(0..n-1)] to [(0..m-1)] *)

  lemma pigeon_hole :
    forall n,m:int, f: int -> int.
    range f n m /\ n > m -> not injective f n m

end




(** {2 Patience unproved code} *)


module PatienceCode

  use import int.Int
  use import list.List
  use import list.RevAppend

  (** this code was the one written initially, without any
      specification or proofs, except for termination.
      It can be tested, see below. *)

  type card = int

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.
  *)
  let rec push_card (c:card) (stacks : list (list card))
     (acc : list (list card)) : list (list card)
    variant  { stacks }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      rev_append (Cons (Cons c Nil) acc) Nil
    | Cons stack remaining_stacks ->
        match stack with
        | Nil -> absurd (* can not be proved unreachable yet *)
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             rev_append (Cons (Cons c stack) acc) remaining_stacks
           else
             (* try next stack *)
             push_card c remaining_stacks (Cons stack acc)
        end
     end

  let rec play_cards (input: list card) (stacks: list (list card))
    : list (list card)
    variant { input }
  =
    match input with
    | Nil -> stacks
    | Cons c rem ->
        let stacks' = push_card c stacks Nil in
        play_cards rem stacks'
    end


  let play_game (input: list card) : list (list card) =
    play_cards input Nil


  (** test, can be run using [why3 patience.mlw --exec PatienceCode.test] *)
  let test () =
    (** the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end


(** {2 Patience game with specifications and proofs} *)

module Patience

  use import int.Int

  type card = int

  (** {3 Ghost state} *)

  (** To specify the expected behavior of the code, we attach a ghost
      state to each step of the algorithm. This state provides extra
      information needed for the final properties to establish.

  *)

  use import map.Map

  type state = {
    mutable num_elts : int;
    (** number of cards already seen *)
    mutable values : map int card;
    (** cards values seen, indexed in the order they have been seen,
        from [0] to [num_elts-1] *)
    mutable num_stacks : int;
    (** number of stacks built so far *)
    mutable stack_sizes : map int int;
    (** sizes of these stacks, numbered from [0] to [num_stacks - 1] *)
    mutable stacks : map int (map int int);
    (** indexes of the cards in respective stacks *)
    mutable positions : map int (int,int);
    (** table that given a card index, provides its position, i.e. in
        which stack it is and at which height *)
    mutable preds : map int int;
    (** predecessors of cards, i.e. for each card index [i], [preds[i]]
        provides an index of a card in the stack on the immediate left,
        whose value is smaller. Defaults to [-1] if the card is on the
        leftmost stack. *)
  }

(** {3 Invariants on the ghost state} *)

  predicate inv (s:state) =
     0 <= s.num_stacks <= s.num_elts
     (** the number of stacks is less or equal the number of cards *)
  /\ (s.num_elts > 0 -> s.num_stacks > 0)
     (** when there is at least one card, there is at least one stack *)
  /\ (forall i. 0 <= i < s.num_stacks ->
         s.stack_sizes[i] >= 1
         (** stacks are non-empty *)
      /\ forall j. 0 <= j < s.stack_sizes[i] ->
           0 <= s.stacks[i][j] < s.num_elts)
         (** contents of stacks are valid card indexes *)
  /\ (forall i. 0 <= i < s.num_elts ->
       let (is,ip) = s.positions[i] in
       0 <= is < s.num_stacks &&
       let st = s.stacks[is] in
         0 <= ip < s.stack_sizes[is] &&
         st[ip] = i)
     (** the position table of cards is correct, i.e. when
        [(is,ip) = s.positions[i]] then card [i] indeed
        occurs in stack [is] at height [ip] *)
  /\ (forall is. 0 <= is < s.num_stacks ->
        forall ip. 0 <= ip < s.stack_sizes[is] ->
        let idx = s.stacks[is][ip] in
        (is,ip) = s.positions[idx])
     (** positions is the proper inverse of stacks *)
  /\ (forall i. 0 <= i < s.num_stacks ->
        let stack_i = s.stacks[i] in
        forall j,k. 0 <= j < k < s.stack_sizes[i] ->
           stack_i[j] < stack_i[k])
     (** in a given stack, indexes are increasing from bottom to top *)
  /\ (forall i. 0 <= i < s.num_stacks ->
        let stack_i = s.stacks[i] in
        forall j,k. 0 <= j <= k < s.stack_sizes[i] ->
           s.values[stack_i[j]] >= s.values[stack_i[k]])
     (** in a given stack, card values are decreasing from bottom to top *)
  /\ (forall i. 0 <= i < s.num_elts ->
       let pred = s.preds[i] in
       -1 <= pred < s.num_elts &&
       (** the predecessor is a valid index or [-1] *)
       pred < i /\
       (** predecessor is always a smaller index *)
       let (is,_ip) = s.positions[i] in
       if pred < 0 then is = 0
         (** if predecessor is [-1] then [i] is in leftmost stack *)
       else
         s.values[pred] < s.values[i] /\
         (** if predecessor is not [-1], it denotes a card with smaller value... *)
         is > 0 &&
         (** ...the card is not on the leftmost stack... *)
         let (ps,_pp) = s.positions[pred] in
         ps = is - 1)
         (** ...and predecessor is in the stack on the immediate left *)



(** glue between the ghost state and the stacks of cards *)

  use import list.List
  use import list.Length
  use import list.NthNoOpt

  predicate glue (s:state) (st:list (list card)) =
    length st = s.num_stacks /\
    forall i. 0 <= i < length st ->
      let st_i = nth i st in
      length st_i = s.stack_sizes[i] /\
      let stack_i = s.stacks[i] in
      forall j. 0 <= i < length st_i ->
        nth j st_i = s.values[stack_i[j]]




(** {2 The patience game with specifications} *)



  use import list.RevAppend


(** {3 playing a card} *)


  (** [push_card c st acc] pushes card [c] on card stacks [st],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.
  *)
  let rec push_card (c:card) (st : list (list card))
     (acc : list (list card)) (ghost state:state) (ghost i:int) 
     (ghost pred:int) : list (list card)
    requires { inv state }
    variant  { st }
    writes   { state } 
    ensures  { inv state }
    ensures  { state.num_elts = (old state).num_elts + 1 }
    ensures  { state.values = (old state).values[(old state).num_elts <- c] }
  =
    match st with
    | Nil ->
      (* we put card [c] in a new stack *)
      let new_stacks = rev_append (Cons (Cons c Nil) acc) Nil in
      (* update the ghost state *)
      let idx = state.num_elts in
      let i = state.num_stacks in
      let stack_i = state.stacks[i] in
      let new_stack_i = stack_i[0 <- idx] in
      state.num_elts <- idx + 1;
      state.values <- state.values[idx <- c];
      state.num_stacks <- state.num_stacks + 1;
      state.stack_sizes <- state.stack_sizes[i <- 1];
      state.stacks <- state.stacks[i <- new_stack_i];
      state.positions <- state.positions[idx <- (i,0)];
      state.preds <- state.preds[idx <- pred];
      new_stacks
    | Cons stack remaining_stacks ->
        match stack with
        | Nil -> absurd (* can not be proved unreachable yet *)
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             let new_stacks =
               rev_append (Cons (Cons c stack) acc) remaining_stacks
             in
             (* update the ghost state *)
             state.num_elts <- state.num_elts + 1;
             new_stacks
           else
             (* try next stack *)
             let ghost stack_i = state.stacks[i] in
             let ghost stack_i_size = state.stack_sizes[i] in
             let ghost top_stack_i = stack_i[stack_i_size - 1] in
             push_card c remaining_stacks (Cons stack acc) state top_stack_i (i+1)
        end
     end



  val play_card (c:card) (st : list (list card)) (ghost state:state) : list (list card)
    requires { inv state }
    requires { glue state st }
    writes   { state } 
    ensures  { inv state }
    ensures  { state.num_elts = (old state).num_elts + 1 }
    ensures  { state.values = (old state).values[(old state).num_elts <- c] }
    ensures  { glue state result }
  

(** {3 playing cards} *)


  use import ref.Ref


  let rec play_cards (input: list card) (stacks: list (list card))
    (ghost state:state) : list (list card)
    requires { inv state }
    requires { glue state stacks }
    variant  { input }
    writes   { state }
    ensures  { inv state }
    ensures  { state.num_elts = (old state).num_elts + length input }
    ensures  { forall i. 0 <= i < (old state).num_elts ->
                 state.values[i] = (old state).values[i] }
    ensures  { forall i. (old state).num_elts <= i < state.num_elts ->
                 state.values[i] = nth (i - (old state).num_elts) input }
    ensures  { glue state result }
  =
    match input with
    | Nil -> stacks
    | Cons c rem ->
        let stacks' = play_card c stacks state in
        play_cards rem stacks' state
    end







(** {3 playing a whole game} *)

  type seq 'a = { seqlen: int; seqval: map int 'a }
  (** a sequence is defined by a length and a mapping *)

  (** definition of an increasing sub-sequence of a list of card *)
  predicate increasing_subsequence (sigma:seq int) (l:list card) =
       0 <= sigma.seqlen <= length l
       (** the length of [sigma] is at most the number of cards *)
    && (forall i. 0 <= i < sigma.seqlen -> 0 <= sigma.seqval[i] < length l)
       (** [sigma] maps indexes to valid indexes in the card list *)
    && (forall i,j. 0 <= i < j < sigma.seqlen -> sigma.seqval[i] < sigma.seqval[j])
       (** [sigma] is an increasing sequence of indexes *)
    && (forall i,j. 0 <= i < j < sigma.seqlen ->
          nth sigma.seqval[i] l < nth sigma.seqval[j] l)
       (** the card values denoted by [sigma] are increasing *)

  use import PigeonHole

  let play_game (input: list card) : list (list card)
    requires { length input > 0 }
    ensures  { exists sigma: seq int.
                 sigma.seqlen = length result /\
                 increasing_subsequence sigma input
             }
    ensures  { forall sigma: seq int.
                increasing_subsequence sigma input ->
                  sigma.seqlen <= length result
             }
  = let ghost state = {
      num_elts = 0;
      values = Map.const (-1) ;
      num_stacks = 0;
      stack_sizes = Map.const 0;
      stacks = Map.const (Map.const (-1));
      positions = Map.const (-1,-1);
      preds = Map.const (-1);
    }
    in
    let final_stacks = play_cards input Nil state in
    assert { forall i. 0 <= i < length input -> nth i input = state.values[i] };
    (**

      This is ghost code to build an increasing subsequence of maximal length

    *)
    let ghost ns = state.num_stacks in
    let ghost _sigma =
      if ns = 0 then
      begin
        assert { input = Nil };
        absurd
(*
        TODO: if input is empty, we may be able to prove that:
        let sigma = { seqlen = 0 ; seqval = Map.const (-1) } in
        assert { increasing_subsequence sigma input };
        sigma
*)
      end
    else
    let ghost last_stack = state.stacks[ns-1] in
    let ghost idx = ref (last_stack[state.stack_sizes[ns-1]-1]) in
    let ghost seq = ref (Map.const (-1)) in
    for i = ns-1 downto 0 do
       invariant { -1 <= !idx < state.num_elts }
       invariant { i >= 0 -> !idx >= 0 &&
         let (is,_) = state.positions[!idx] in is = i }
       invariant { i+1 < ns -> !idx < !seq[i+1] }
       invariant { 0 <= i < ns-1 -> state.values[!idx] < state.values[!seq[i+1]] }
       invariant { forall j. i < j < ns -> 0 <= !seq[j] < state.num_elts }
       invariant { forall j,k. i < j < k < ns -> !seq[j] < !seq[k] }
       invariant { forall j,k. i < j < k < ns ->
         state.values[!seq[j]] < state.values[!seq[k]]
       }
       'L:
       seq := !seq[i <- !idx];
       idx := state.preds[!idx];
    done;
    let ghost sigma = { seqlen = ns ; seqval = !seq } in
    assert { increasing_subsequence sigma input };
    (**

      These are assertions to prove that no increasing subsequence of
      length larger than the number of stacks may exists

    *)
    assert {  (* non-injectivity *)
      forall sigma: seq int.
        increasing_subsequence sigma input /\ sigma.seqlen > state.num_stacks ->
        let f = \i:int.
          let si = sigma.seqval[i] in
          let (stack_i,_) = state.positions[si] in
          stack_i
        in range f sigma.seqlen state.num_stacks &&
           not (injective f sigma.seqlen state.num_stacks)
    };
    assert {  (* non-injectivity *)
      forall sigma: seq int.
        increasing_subsequence sigma input /\ sigma.seqlen > state.num_stacks ->
        exists i,j.
          0 <= i < j < sigma.seqlen &&
          let si = sigma.seqval[i] in
          let sj = sigma.seqval[j] in
          let (stack_i,_pi) = state.positions[si] in
          let (stack_j,_pj) = state.positions[sj] in
          stack_i = stack_j
    };
    assert { (* contradiction from non-injectivity *)
      forall sigma: seq int.
        increasing_subsequence sigma input /\ sigma.seqlen > state.num_stacks ->
        forall i,j.
          0 <= i < j < sigma.seqlen ->
          let si = sigma.seqval[i] in
          let sj = sigma.seqval[j] in
          let (stack_i,pi) = state.positions[si] in
          let (stack_j,pj) = state.positions[sj] in
          stack_i = stack_j ->
          si < sj && pi < pj && state.values[si] < state.values[sj]
    };
    sigma
  in
  final_stacks

end
