


(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)


module Patience

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import list.Reverse

  (** {2 Ghost state} *)

  (** To specify the expected behavior of the code, we attach a ghost
      state to each step of the algorithm. This state provides extra
      information needed for the final property to establish: (1) the
      number of elements [len] in the input sequence (2) a map [elts]
      associating to each i from 0 to [len-1] the value of th ith card and in which stack it is (3)
      the indexes of each top element of all stacks (4) a map
      [preds] associating to each i from 0 to [len-1] a "predecessor": the
      index j of a smaller element in the sequence that appears in the
      stack immediately on the left (-1 if already on the leftmost
      stack). Here is what happens on the example sequence [[9, 7, 10,
      9, 5, 4, 10]] :

{h <pre>}
len=0
len=1, elts(0) = (9,0),  top(0) = 0, preds(0) = -1
len=2, elts(1) = (7,0),  top(0) = 1, preds(1) = -1
len=3, elts(2) = (10,1), top(1) = 2, preds(2) = 1 
  (top(0), works because predecessor is 7 = fst(elts(1)))
len=4, elts(3) = (9,1),  top(1) = 3, preds(3) = 1 
len=5, elts(4) = (5,0),  top(0) = 4, preds(4) = -1
len=6, elts(5) = (4,0),  top(0) = 5, preds(5) = -1
len=7, elts(6) = (10,2), top(2) = 6, preds(6) = 3 (top(1)), hence predecessor is fst(elts(3)) = 9)
{h </pre>}

as we see, the predessor of a new added card is always the top of the
stack on the left.

At the end, an increasing subsequence of length n is found by taking,
in reverse order, the top of the rightmost stack, then its predecessor
and so on.

*)

  use import map.Map

  type state = {
    mutable num_elts : int;
    mutable elts : map int (int,int);
    mutable top_stacks : map int int;
    mutable preds : map int int;
  }

(*

invariants:

*)

  use import list.NthNoOpt (* for the [nth] operator on lists *)

  (** these lemmas should have been in Why3 stdlib ! *)
  let rec lemma nth_append_1 (l1 l2: list 'a) (i: int)
    requires { 0 <= i < length l1 }
    variant  { l1 }
    ensures  { nth i (l1 ++ l2) = nth i l1 }
  = match l1 with
    | Nil -> ()
    | Cons _ l -> if i = 0 then () else nth_append_1 l l2 (i-1)
    end

  let rec lemma nth_append_2 (l1 l2: list 'a) (i: int)
    requires { length l1 <= i < length l1 + length l2 }
    variant  { l1 }
    ensures  { nth i (l1 ++ l2) = nth (i - length l1) l2 }
  = match l1 with
    | Nil -> ()
    | Cons _ l -> nth_append_2 l l2 (i-1)
    end

  predicate inv (s:state) (stacks:list (list int)) =
    s.num_elts >= 0
  /\
    (** [s.top_stacks[i]] denotes the index
        of the top of the [i]-th stack of [stacks] *)
    (forall i. 0 <= i < length stacks ->
      let stack_i = nth i stacks in
      match stack_i with
      | Nil -> false (* stacks are non-empty *)
      | Cons hd _ ->
        let idx = s.top_stacks[i] in
        0 <= idx < s.num_elts /\ let (e,_) = s.elts[idx] in e = hd
      end)
  /\
    (forall i. 0 <= i < s.num_elts ->
      let j = s.preds[i] in
        -1 <= j < s.num_elts /\ (j >= 0 -> 
          let (ej,sj) = s.elts[j] in
          let (ei,si) = s.elts[i] in
          ej < ei /\ si > 0 /\ sj = si - 1))

  (** {2 Programs} *)

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.
  *)

  let rec push_card (c:int) (stacks : list (list int))
     (acc : list (list int)) (ghost s: state)
     : list (list int)
    requires { inv s (reverse acc ++ stacks) }
    requires { (* c is greater than the top of the previous stack *)
               match acc with 
               | Cons (Cons c' _) _ -> c > c'
               | _ -> true
               end }
    variant  { stacks }
    writes   { s }
    ensures  { inv s result }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      let new_stacks = reverse (Cons (Cons c Nil) acc) in
      (* update of the ghost state *)
      let ghost old_stacks = reverse acc ++ stacks in
      let ghost lacc = length acc in
      assert { lacc = length old_stacks };
      assert { old_stacks = reverse acc };
      assert { new_stacks = old_stacks ++ (Cons (Cons c Nil) Nil) };
      assert { length new_stacks = length old_stacks + 1 };
      assert { forall i. 0 <= i < lacc ->
                 nth i new_stacks = nth i old_stacks };
      assert { nth lacc new_stacks = Cons c Nil };
      let ghost l = s.num_elts in
      s.num_elts <- l + 1;
      s.elts <- s.elts[l <- (c,lacc)];
      let ghost p = if lacc = 0 then -1 else s.top_stacks[lacc-1] in
      s.preds <- s.preds[l <- p];
      s.top_stacks <- s.top_stacks[lacc <- l];
      new_stacks
    | Cons stack remaining_stacks ->
        match stack with
        | Nil ->
            let ghost lacc = length acc in
            assert { stack = nth lacc (reverse acc ++ stacks) };
            absurd
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             let new_stacks =
               (* TODO: use rev_append directly for efficiency of the code *)
               (reverse (Cons (Cons c stack) acc)) ++ remaining_stacks in
             (* update of the ghost state *)
             let ghost old_stacks = reverse acc ++ stacks in
             assert { new_stacks =
               reverse acc ++ (Cons (Cons c stack) Nil) ++ remaining_stacks };
             assert { length new_stacks = length old_stacks };
             let ghost lacc = length acc in
             assert { forall i. 0 <= i < length old_stacks ->
               i <> lacc -> nth i new_stacks = nth i old_stacks };
             assert { nth lacc new_stacks = Cons c (nth lacc old_stacks) } ;
             let ghost l = s.num_elts in
             s.num_elts <- l + 1;
             s.elts <- s.elts[l<-(c,lacc)];
             let ghost p = if lacc = 0 then -1 else s.top_stacks[lacc-1] in
             s.preds <- s.preds[l <- p];
             s.top_stacks <- s.top_stacks[lacc <- l];
             new_stacks
           else
             (* try next stack *)
             push_card c remaining_stacks (Cons stack acc) s
        end
     end

  let rec play_cards (input: list int) (stacks: list (list int))
    (ghost s: state) : list (list int)
    requires { inv s stacks }
    variant  { input }
    writes   { s }
    requires { inv s stacks }
  =
    match input with
    | Nil -> stacks
    | Cons c rem ->
        let stacks' = push_card c stacks Nil s in
        play_cards rem stacks' s
    end


  let play_game (input: list int) : list (list int)
    requires { true }
    ensures { true }
  = let ghost s = {
      num_elts = 0;
      elts = Map.const (-1,-1) ;
      top_stacks = Map.const (-1);
      preds = Map.const (-1);
    }
    in
    play_cards input Nil s


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end