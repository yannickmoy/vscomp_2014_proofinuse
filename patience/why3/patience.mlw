


(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)


module Patience

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import list.Reverse

  (** {2 Specifications} *)

  (** a sequence of stacks is well-formed iff each stack is non-empty
      and increasing *)
  predicate increasing_stack (stack: list int) =
    match stack with
    | Nil -> false
    | Cons _ Nil -> true
    | Cons c1 (Cons c2 _ as rem) -> c1 <= c2 /\ increasing_stack rem
    end

  predicate wf_stacks (stacks: list (list int)) =
    match stacks with
    | Nil -> true
    | Cons s rem -> increasing_stack s /\ wf_stacks rem
    end

  (** lemma: concatenation of well-formed sequences of stacks results in
      a well-formed sequence of stacks.
      Structural induction done via a lemma function *)
  let rec lemma wf_append_stacks (s1 s2: list (list int))
    requires { wf_stacks s1 }
    requires { wf_stacks s2 }
    variant { s1 }
    ensures { wf_stacks (s1 ++ s2) }
  = match s1 with
    | Nil -> ()
    | Cons _ rem -> wf_append_stacks rem s2
    end

  (** {2 Programs} *)

  use import map.Map
  use import ref.Ref

  (** [push_card c stacks acc] pushes card [c] on stacks [stacks],
      assuming [acc] is an accumulator (in reverse order) of stacks
      where [c] could not be pushed.

      [witness] is an "out" and ghost parameter, providing a witness
      of an increasing subsequence of the input of the same length as
      the result
  *)

  let rec push_card (c:int) (stacks : list (list int))
     (acc : list (list int)) (ghost witness: ref (int,map int int)) 
     : list (list int)
    requires { wf_stacks stacks }
    requires { wf_stacks (reverse acc) }
    requires { let (n,_m) = !witness in n = length stacks + length acc }
    variant  { stacks }
    writes   { witness }
    ensures  { wf_stacks result }
    ensures  { let (n,_m) = !witness in n = length result }
  =
    match stacks with
    | Nil ->
      (* we put card [c] in a new stack *)
      let (n,m) = !witness in witness := (n+1,Map.set m n c);
      reverse (Cons (Cons c Nil) acc)
    | Cons stack stacks ->
        match stack with
        | Nil -> absurd
        | Cons c' _ ->
           if c <= c' then
             (* card is placed on the leftmost stack where its card
                value is no greater than the topmost card on that
                stack *)
             (reverse (Cons (Cons c stack) acc)) ++ stacks
           else
             (* try next stack *)
             push_card c stacks (Cons stack acc) witness
        end
     end

  let rec play_cards (input: list int) (stacks: list (list int))
    (ghost witness: ref (int,map int int)) : list (list int)
    requires { wf_stacks stacks }
    requires { let (n,_m) = !witness in n = length stacks }
    variant  { input }
    writes   { witness }
    ensures  { let (n,_m) = !witness in n = length result }
  =
    match input with
    | Nil -> stacks
    | Cons c rem -> 
        let stacks' = push_card c stacks Nil witness in
        play_cards rem stacks' witness
    end


  let play_game (input: list int) : list (list int)
    requires { true }
    ensures { true }
  = let ghost witness = ref (0,Map.const 0) in
    play_cards input Nil witness


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end