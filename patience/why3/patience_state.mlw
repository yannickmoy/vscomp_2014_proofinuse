


(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)


module Patience

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import list.Reverse

  (** {2 Ghost state} *)

  (** To specify the expected behavior of the code, we attach a ghost
      state to each step of the algorithm. This state provides extra
      information needed for the final property to establish: (1) the
      number of elements [len] in the input sequence (2) a map [elts]
      associating to each i from 0 to [len-1] the value of th ith card and in which stack it is (3)
      the indexes of each top element of all stacks (4) a map
      [preds] associating to each i from 0 to [len-1] a "predecessor": the
      index j of a smaller element in the sequence that appears in the
      stack immediately on the left (-1 if already on the leftmost
      stack). Here is what happens on the example sequence [[9, 7, 10,
      9, 5, 4, 10]] :

{h <pre>}
len=0
len=1, elts(0) = (9,0),  top(0) = 0, preds(0) = -1
len=2, elts(1) = (7,0),  top(0) = 1, preds(1) = -1
len=3, elts(2) = (10,1), top(1) = 2, preds(2) = 1
  (top(0), works because predecessor is 7 = fst(elts(1)))
len=4, elts(3) = (9,1),  top(1) = 3, preds(3) = 1
len=5, elts(4) = (5,0),  top(0) = 4, preds(4) = -1
len=6, elts(5) = (4,0),  top(0) = 5, preds(5) = -1
len=7, elts(6) = (10,2), top(2) = 6, preds(6) = 3 (top(1)), hence predecessor is fst(elts(3)) = 9)
{h </pre>}

as we see, the predessor of a new added card is always the top of the
stack on the left.

At the end, an increasing subsequence of length n is found by taking,
in reverse order, the top of the rightmost stack, then its predecessor
and so on.

*)

  use import map.Map

  type card = int

  type state = {
    mutable num_elts : int;
    mutable values : map int card;
    mutable num_stacks : int;
    mutable stack_sizes : map int int;
    mutable stacks : map int (map int int);
    mutable positions : map int (int,int);
      (* positions[i] = (stack num, position in stack) *)
    mutable preds : map int int;
  }

  predicate inv (s:state) =
     s.num_elts >= 0
  /\ s.num_stacks >= 0
  /\ (forall i. 0 <= i < s.num_stacks ->
         s.stack_sizes[i] >= 0
      /\ forall j. 0 <= j < s.stack_sizes[i] -> 
           0 <= s.stacks[i][j] < s.num_elts)
  /\ (* injectivity of stacks ?*)
     true
  /\ (* positions *)   
     (forall i. 0 <= i < s.num_elts ->
       let (is,ip) = s.positions[i] in
       0 <= is < s.num_stacks /\
       let st = s.stacks[is] in 
         0 <= ip < s.stack_sizes[is] /\
         st[ip] = i)


  (** {2 Programs} *)

  use import ref.Ref
  exception Return

  (** [play_card c i s] pushes the card [c] on state [s] *)
  let play_card (c:card) (s:state) : unit
    requires { inv s }
    writes   { s }
    ensures  { inv s }
  =
    let pred = ref (-1) in
    try
    for i = 0 to s.num_stacks - 1 do
      invariant { inv s }
      let stack_i = s.stacks[i] in
      let stack_i_size = s.stack_sizes[i] in
      let top_stack_i = stack_i[stack_i_size - 1] in
      if c <= s.values[top_stack_i] then
         (* we put c on top of stack i *)
         let idx = s.num_elts in
         let new_stack_i = stack_i[stack_i_size <- idx] in
         s.num_elts <- idx + 1;
         s.values <- s.values[idx <- c];
         (* s.num_stacks unchanged *)
         s.stack_sizes <- s.stack_sizes[i <- stack_i_size + 1];
         s.stacks <- s.stacks[i <- new_stack_i];
         s.positions <- s.positions[idx <- (i,stack_i_size)];
         s.preds <- s.preds[idx <- !pred];
         assert { inv s };
         raise Return;
      else
         pred := top_stack_i
    done;
    (* we add a new stack *)
    let idx = s.num_elts in
    let i = s.num_stacks in
    let stack_i = s.stacks[i] in
    let new_stack_i = stack_i[0 <- idx] in
    s.num_elts <- idx + 1;
    s.values <- s.values[idx <- c];
    s.num_stacks <- s.num_stacks + 1;
    s.stack_sizes <- s.stack_sizes[i <- 1];
    s.stacks <- s.stacks[i <- new_stack_i];
    s.positions <- s.positions[idx <- (i,0)];
    s.preds <- s.preds[idx <- !pred];
    assert { inv s };
    ()
  with Return -> ()
  end

  let rec play_cards (input: list int) (s: state) : unit
    requires { inv s }
    variant  { input }
    writes   { s }
    requires { inv s }
  =
    match input with
    | Nil -> ()
    | Cons c rem -> play_card c s; play_cards rem s
    end


  let play_game (input: list int) : state
    requires { true }
    ensures { true }
  = let s = {
      num_elts = 0;
      values = Map.const (-1) ;
      num_stacks = 0;
      stack_sizes = Map.const 0;
      stacks = Map.const (Map.const (-1));
      positions = Map.const (-1,-1);
      preds = Map.const (-1);
    }
    in
    play_cards input s;
    s


  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end