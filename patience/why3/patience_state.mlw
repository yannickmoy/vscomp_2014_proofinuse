


(** {1 The Patience Solitaire Game}

Problem 1 from the {h <a href="http://vscomp.org/">Verified Software
Competition 2014</a>}

Patience Solitaire is played by taking cards one-by-one from a deck of
cards and arranging them face up in a sequence of stacks arranged from
left to right as follows. The very first card from the deck is kept
face up to form a singleton stack. Each subsequent card is placed on
the leftmost stack where its card value is no greater than the topmost
card on that stack. If there is no such stack, then a new stack is
started to right of the other stacks. We can do this with positive
numbers instead of cards. If the input sequence is 9, 7, 10, 9, 5, 4,
and 10, then the stacks develop as

{h <pre>}
<[[9]]>
<[[7, 9]]>
<[[7, 9]], [[10]]>
<[[7, 9]], [[9, 10]]>
<[[5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]]>
<[[4, 5, 7, 9]], [[9, 10]], [[10]]>
{h </pre>}

Verify the claim is that the number of stacks at the end of the game
is the length of the longest (strictly) increasing subsequence in the
input sequence.


*)


module Patience

  use import int.Int
  use import list.List
  use import list.Length
  use import list.Append
  use import list.Reverse

  (** {2 Ghost state} *)

  (** To specify the expected behavior of the code, we attach a ghost
      state to each step of the algorithm. This state provides extra
      information needed for the final property to establish: (1) the
      number of elements [len] in the input sequence (2) a map [elts]
      associating to each i from 0 to [len-1] the value of th ith card and in which stack it is (3)
      the indexes of each top element of all stacks (4) a map
      [preds] associating to each i from 0 to [len-1] a "predecessor": the
      index j of a smaller element in the sequence that appears in the
      stack immediately on the left (-1 if already on the leftmost
      stack). Here is what happens on the example sequence [[9, 7, 10,
      9, 5, 4, 10]] :

{h <pre>}
len=0
len=1, elts(0) = (9,0),  top(0) = 0, preds(0) = -1
len=2, elts(1) = (7,0),  top(0) = 1, preds(1) = -1
len=3, elts(2) = (10,1), top(1) = 2, preds(2) = 1
  (top(0), works because predecessor is 7 = fst(elts(1)))
len=4, elts(3) = (9,1),  top(1) = 3, preds(3) = 1
len=5, elts(4) = (5,0),  top(0) = 4, preds(4) = -1
len=6, elts(5) = (4,0),  top(0) = 5, preds(5) = -1
len=7, elts(6) = (10,2), top(2) = 6, preds(6) = 3 (top(1)), hence predecessor is fst(elts(3)) = 9)
{h </pre>}

as we see, the predessor of a new added card is always the top of the
stack on the left.

At the end, an increasing subsequence of length n is found by taking,
in reverse order, the top of the rightmost stack, then its predecessor
and so on.

*)

  use import map.Map

  type card = int

  type state = {
    mutable num_elts : int;
    mutable values : map int card;
    mutable num_stacks : int;
    mutable stack_sizes : map int int;
    mutable stacks : map int (map int int);
    mutable positions : map int (int,int);
      (* positions[i] = (stack num, position in stack) *)
    mutable preds : map int int;
  }

  predicate inv (s:state) =
     0 <= s.num_stacks <= s.num_elts
  /\ (s.num_elts > 0 -> s.num_stacks > 0)
  /\ (forall i. 0 <= i < s.num_stacks ->
         s.stack_sizes[i] >= 1 (* stacks are non-empty *)
      /\ forall j. 0 <= j < s.stack_sizes[i] ->
           0 <= s.stacks[i][j] < s.num_elts)
  /\ (* positions *)
     (forall i. 0 <= i < s.num_elts ->
       let (is,ip) = s.positions[i] in
       0 <= is < s.num_stacks &&
       let st = s.stacks[is] in
         0 <= ip < s.stack_sizes[is] &&
         st[ip] = i)
  /\ (* positions is inverse of stacks *)
     (forall is. 0 <= is < s.num_stacks ->
        forall ip. 0 <= ip < s.stack_sizes[is] ->
        let idx = s.stacks[is][ip] in
        (is,ip) = s.positions[idx])
  /\ (* injectivity, surjectivity of stacks ? consequence of the above ? *)
     true
  /\ (* predecessors *)
     (forall i. 0 <= i < s.num_elts ->
       let pred = s.preds[i] in
       -1 <= pred < s.num_elts &&
       pred < i /\ (* predecessor is always of a smaller index *)
       let (is,_ip) = s.positions[i] in
       if pred < 0 then is = 0 else
         s.values[pred] < s.values[i] /\ (* predecessor is always of a smaller value *)
         is > 0 &&
         let (ps,_pp) = s.positions[pred] in
         ps = is - 1) (* predecessor is in the stack on the immediate left *)


  (** {2 Programs} *)

  use import ref.Ref
  exception Return int

  (** [play_card c i s] pushes the card [c] on state [s] *)
  let play_card (c:card) (s:state) : unit
    requires { inv s }
    writes   { s }
    ensures  { inv s }
    ensures  { s.num_elts = (old s).num_elts + 1 }
    ensures  { s.values = (old s).values[(old s).num_elts <- c] }
  =
    let pred = ref (-1) in
    try
    for i = 0 to s.num_stacks - 1 do
      invariant { if i=0 then !pred = -1 else
        let stack_im1 = s.stacks[i-1] in
        let stack_im1_size = s.stack_sizes[i-1] in
        let top_stack_im1 = stack_im1[stack_im1_size - 1] in
        !pred = top_stack_im1 /\
        c > s.values[!pred]  /\
        0 <= !pred < s.num_elts /\
        let (ps,_pp) = s.positions[!pred] in
        ps = i - 1
      }
      let stack_i = s.stacks[i] in
      let stack_i_size = s.stack_sizes[i] in
      let top_stack_i = stack_i[stack_i_size - 1] in
      if c <= s.values[top_stack_i] then
         raise (Return i)
      else
         begin
           assert { 0 <= top_stack_i < s.num_elts };
           assert { let (is,ip) = s.positions[top_stack_i] in
             0 <= is < s.num_stacks &&
             0 <= ip < s.stack_sizes[is] &&
             s.stacks[is][ip] = top_stack_i &&
             is = i /\ ip = stack_i_size - 1
           };
           pred := top_stack_i
         end
    done;
    (* we add a new stack *)
    let idx = s.num_elts in
    let i = s.num_stacks in
    let stack_i = s.stacks[i] in
    let new_stack_i = stack_i[0 <- idx] in
    s.num_elts <- idx + 1;
    s.values <- s.values[idx <- c];
    s.num_stacks <- s.num_stacks + 1;
    s.stack_sizes <- s.stack_sizes[i <- 1];
    s.stacks <- s.stacks[i <- new_stack_i];
    s.positions <- s.positions[idx <- (i,0)];
    s.preds <- s.preds[idx <- !pred]
  with Return i ->
         let stack_i = s.stacks[i] in
         let stack_i_size = s.stack_sizes[i] in
         (* we put c on top of stack i *)
         let idx = s.num_elts in
         let new_stack_i = stack_i[stack_i_size <- idx] in
         s.num_elts <- idx + 1;
         s.values <- s.values[idx <- c];
         (* s.num_stacks unchanged *)
         s.stack_sizes <- s.stack_sizes[i <- stack_i_size + 1];
         s.stacks <- s.stacks[i <- new_stack_i];
         s.positions <- s.positions[idx <- (i,stack_i_size)];
         s.preds <- s.preds[idx <- !pred];
  end

  let rec play_cards (input: list int) (s: state) : unit
    requires { inv s }
    variant  { input }
    writes   { s }
    ensures  { inv s }
    ensures  { s.num_elts = (old s).num_elts + length input }
  =
    match input with
    | Nil -> ()
    | Cons c rem -> play_card c s; play_cards rem s
    end

  type seq 'a = { seqlen: int; seqval: map int 'a }

  use import list.NthNoOpt

  predicate increasing_subsequence (s:seq int) (l:list int) =
    0 <= s.seqlen <= length l &&
    (* subsequence *)
    ((forall i. 0 <= i < s.seqlen -> 0 <= s.seqval[i] < length l)
    /\ (forall i,j. 0 <= i < j < s.seqlen -> s.seqval[i] < s.seqval[j]))
    (* increasing *)
    && (forall i,j. 0 <= i < j < s.seqlen ->
          nth s.seqval[i] l < nth s.seqval[j] l)

  let play_game (input: list int) : state
    (* requires { length input > 0 } *)
    ensures { exists s: seq int.  s.seqlen = result.num_stacks /\
        increasing_subsequence s input
      }
    ensures { forall s: seq int.
        increasing_subsequence s input -> s.seqlen <= result.num_stacks
      }
  = let s = {
      num_elts = 0;
      values = Map.const (-1) ;
      num_stacks = 0;
      stack_sizes = Map.const 0;
      stacks = Map.const (Map.const (-1));
      positions = Map.const (-1,-1);
      preds = Map.const (-1);
    }
    in
    play_cards input s;
    (* ghost code to build an increasing subsequence of maximal length *)
    let ns = s.num_stacks in
    if ns = 0 then
      begin
        assert { input = Nil };
        let seq = { seqlen = 0 ; seqval = Map.const (-1) } in
        assert { increasing_subsequence seq input };
        s
      end
    else
    let last_stack = s.stacks[ns-1] in
    let idx = ref (last_stack[s.stack_sizes[ns-1]-1]) in
    let seq = ref (Map.const (-1)) in
    for i = ns-1 downto 0 do
       invariant { -1 <= !idx < s.num_elts }
       invariant { i >= 0 -> !idx >= 0 &&
         let (is,ip) = s.positions[!idx] in is = i }
       invariant { i+1 < ns -> !idx < !seq[i+1] }
       invariant { forall j. i < j < ns -> 0 <= !seq[j] < s.num_elts }
       invariant { forall j,k. i < j < k < ns -> !seq[j] < !seq[k] }
       invariant { forall j,k. i < j < k < ns ->
         nth !seq[j] input < nth !seq[k] input
       }
       'L:
       seq := !seq[i <- !idx];
       idx := s.preds[!idx];
       (* assert { forall j. i < j < ns -> !seq[i] < !seq[j] }; *)
    done;
    let seq = { seqlen = ns ; seqval = !seq } in
    assert { increasing_subsequence seq input };
    s

  let test () =
    (* the list given in the problem description
       9, 7, 10, 9, 5, 4, and 10 *)
    play_game
      (Cons 9 (Cons 7 (Cons 10 (Cons 9 (Cons 5 (Cons 4 (Cons 10 Nil)))))))

end